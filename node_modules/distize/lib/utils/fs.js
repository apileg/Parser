"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.remove = remove;
exports.copy = copy;
var _fs = require("fs");
var _path = require("path");
function lstatPromise(path) {
    return new Promise(function(resolve, reject) {
        (0, _fs).lstat(path, function(err, stat) {
            if (err) {
                return reject(err);
            }
            return resolve(stat);
        });
    });
}
function mkdirRecursivePromise(path) {
    return new Promise(function(resolve, reject) {
        (0, _fs).mkdir(path, {
            recursive: true
        }, function(err) {
            if (err) {
                return reject(err);
            }
            return resolve();
        });
    });
}
function readdirPromise(path) {
    return new Promise(function(resolve, reject) {
        (0, _fs).readdir(path, function(err, files) {
            if (err) {
                return reject(err);
            }
            return resolve(files);
        });
    });
}
function readFilePromise(path) {
    return new Promise(function(resolve, reject) {
        (0, _fs).readFile(path, function(err, data) {
            if (err) {
                return reject(err);
            }
            return resolve(data);
        });
    });
}
function writeFilePromise(path, data) {
    return new Promise(function(resolve, reject) {
        (0, _fs).writeFile(path, data, function(err) {
            if (err) {
                return reject(err);
            }
            return resolve();
        });
    });
}
function rmdirPromise(path) {
    return new Promise(function(resolve, reject) {
        (0, _fs).rmdir(path, function(err) {
            if (err) {
                if (err.code === "ENOTEMPTY") {
                    return resolve();
                }
                return reject(err);
            }
            return resolve();
        });
    });
}
function unlinkPromise(path) {
    return new Promise(function(resolve, reject) {
        (0, _fs).unlink(path, function(err) {
            if (err) {
                return reject(err);
            }
            return resolve();
        });
    });
}
function remove(path) {
    return lstatPromise(path).then(function(status) {
        if (status.isDirectory()) {
            return readdirPromise(path).then(function(files) {
                return files.reduce(function(carry, file) {
                    return carry.then(function() {
                        return remove((0, _path).join(path, file));
                    });
                }, Promise.resolve());
            }).then(function() {
                return rmdirPromise(path);
            });
        }
        return unlinkPromise(path);
    }).catch(function(e) {
        if (e.code === "ENOENT") {
            return;
        }
        return console.error(e);
    });
}
function copy(src, dest) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return lstatPromise(src).then(function(srcStat) {
        // src is directory
        if (srcStat.isDirectory()) {
            return readdirPromise(src).then(function(files) {
                return files.reduce(function(carry, file) {
                    return carry.then(function() {
                        return copy((0, _path).join(src, file), (0, _path).join(dest, file), options);
                    });
                }, Promise.resolve());
            });
        }
        var destDir = (0, _path).dirname(dest);
        return lstatPromise(dest).then(function() {
            return remove(dest);
        }).catch(function(e) {
            if (e.code === "ENOENT") {
                return;
            }
            return console.error(e);
        }).then(function() {
            return lstatPromise(destDir);
        }).catch(function(e) {
            if (e.code === "ENOENT") {
                return mkdirRecursivePromise(destDir);
            }
            return console.error(e);
        }).then(function() {
            return readFilePromise(src);
        }).then(function(body) {
            return writeFilePromise(dest, body).then(function() {
                var ref;
                return (ref = options.onCopy) === null || ref === void 0 ? void 0 : ref.call(options, src, dest);
            });
        });
    });
}

//# sourceMappingURL=fs.js.map